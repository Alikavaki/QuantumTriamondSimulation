
Quantum Triamond Simulation

This project implements Python-based lattice quantum simulations using the Triamond lattice structure. It models a quantum lattice system, generates physical states, and computes the Hamiltonian matrix, accounting for symmetries and transformations in the system.

Note: The States and Hamiltonian classes are designed for handling one row of unit cells. For generating the Hamiltonian and states in more general cases (e.g., multiple rows or dimensions), the code will require future updates to extend its functionality.

Classes Overview

1. Triamond

This class defines a lattice unit cell structure and handles the 3D visualization of the lattice. It includes both points inside the unit cell and points outside the unit cell, connected by specific vectors.

Attributes:
- Unit Cell Points (w1, w2, b1, b2, r1, r2, g1, g2): These represent points within the unit cell.
- Points Outside the Cube (g3, r3, w3, etc.): Points beyond the unit cube for constructing connections in multiple directions.
- Vectors (b, r, g, y, c, m): Representing colored links between points inside the lattice.

Methods:
- __init__(): Initializes the lattice structure by defining points and vectors.
- plot(nx, ny, nz, points): Plots the 3D lattice structure for nx, ny, and nz unit cells. The points parameter is a Boolean flag to toggle displaying the lattice points.

Example:
```python
lattice = Triamond()
lattice.plot(nx=3, ny=3, nz=3, points=True)
```

2. States

The States class generates physical states for a lattice system based on Gauss's law. It checks all possible configurations of variables and validates the ones that comply with the constraints.

Attributes:
- num_unit: Number of unit cells.
- valid_states: Stores valid physical states generated based on Gauss’s law.

Methods:
- __init__(num_unit): Initializes with the number of unit cells.
- generate_states(): Generates valid physical states for the lattice by checking configurations against Gauss’s law.

Example:
```python
states = States(num_unit=2)
valid_states = states.generate_states()
print(valid_states)
```

3. Hamiltonian

This class constructs and calculates the Hamiltonian matrix for a quantum lattice system. It also explores translation and screw transformations to generate new quantum states and symmetries.

Attributes:
- num_unit: Number of unit cells.
- sector: Sector requested for the Hamiltonian (e.g., 'vac_sector', 'ver_sector', 'hor_sector', 'six_sector').
- n_max: Maximum number of plaquettes.
- sub_space: Sub-space of quantum states generated.
- magnetic_part: Magnetic component of the Hamiltonian matrix.
- electric_part: Electric component of the Hamiltonian matrix.

Methods:
- __init__(num_unit, sector): Initializes the Hamiltonian class with the number of unit cells and the sector requested.
- explore_states_with_translation(): Explores unique states generated by applying translation symmetry, where variables are cyclically shifted across unit cells along the x-axis.
- explore_states_with_screw_transformation(): Explores unique states generated by applying screw transformations, involving a π/2 rotation around the x-axis and a translation of one-fourth unit cell along the x-axis.
- compute_hamiltonian(g): Computes the full Hamiltonian matrix, accounting for electric and magnetic components.

Example:
```python
hamiltonian = Hamiltonian(num_unit=4, sector='vac_sector')
translation_symmetry_states = hamiltonian.explore_states_with_translation()
screw_symmetry_states = hamiltonian.explore_states_with_screw_transformation()
H = hamiltonian.compute_hamiltonian(g=1.0)
```

Future Updates

Currently, the States and Hamiltonian classes are only designed for one row of unit cells. The next update will extend the code to handle more general cases with multiple rows or dimensions.
